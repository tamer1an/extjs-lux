{"ts":1377798701837,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*\nThis file is part of Ext JS 4.2\n\nCopyright (c) 2011-2013 Sencha Inc\n\nContact:  http://www.sencha.com/contact\n\nCommercial Usage\nLicensees holding valid commercial licenses may use this file in accordance with the Commercial\nSoftware License Agreement provided with the Software or, alternatively, in accordance with the\nterms contained in a written agreement between you and Sencha.\n\nIf you are unsure which license is appropriate for your use, please contact the sales department\nat http://www.sencha.com/contact.\n\nBuild date: 2013-05-16 14:36:50 (f9be68accb407158ba2b1be2c226a6ce1f649314)\n*/\n// @tag foundation,core\n// @define Ext\n\n/**\n * @class Ext\n * @singleton\n */\nvar Ext = Ext || {};\nExt._startTime = new Date().getTime();\n(function() {\n    var global = this,\n        objectPrototype = Object.prototype,\n        toString = objectPrototype.toString,\n        enumerables = true,\n        enumerablesTest = {toString: 1},\n        emptyFn = function () {},\n        // This is the \"$previous\" method of a hook function on an instance. When called, it\n        // calls through the class prototype by the name of the called method.\n        callOverrideParent = function () {\n            var method = callOverrideParent.caller.caller; // skip callParent (our caller)\n            return method.$owner.prototype[method.$name].apply(this, arguments);\n        },\n        i,\n        nonWhitespaceRe = /\\S/,\n        ExtApp,\n        iterableRe = /\\[object\\s*(?:Array|Arguments|\\w*Collection|\\w*List|HTML\\s+document\\.all\\s+class)\\]/;\n\n    Function.prototype.$extIsFunction = true;\n\n    Ext.global = global;\n\n    for (i in enumerablesTest) {\n        enumerables = null;\n    }\n\n    if (enumerables) {\n        enumerables = ['hasOwnProperty', 'valueOf', 'isPrototypeOf', 'propertyIsEnumerable',\n                       'toLocaleString', 'toString', 'constructor'];\n    }\n\n    /**\n     * An array containing extra enumerables for old browsers\n     * @property {String[]}\n     */\n    Ext.enumerables = enumerables;\n\n    /**\n     * Copies all the properties of config to the specified object.\n     * Note that if recursive merging and cloning without referencing the original objects / arrays is needed, use\n     * {@link Ext.Object#merge} instead.\n     * @param {Object} object The receiver of the properties\n     * @param {Object} config The source of the properties\n     * @param {Object} [defaults] A different object that will also be applied for default values\n     * @return {Object} returns obj\n     */\n    Ext.apply = function(object, config, defaults) {\n        if (defaults) {\n            Ext.apply(object, defaults);\n        }\n\n        if (object && config && typeof config === 'object') {\n            var i, j, k;\n\n            for (i in config) {\n                object[i] = config[i];\n            }\n\n            if (enumerables) {\n                for (j = enumerables.length; j--;) {\n                    k = enumerables[j];\n                    if (config.hasOwnProperty(k)) {\n                        object[k] = config[k];\n                    }\n                }\n            }\n        }\n\n        return object;\n    };\n\n    Ext.buildSettings = Ext.apply({\n        baseCSSPrefix: 'x-'\n    }, Ext.buildSettings || {});\n\n    Ext.apply(Ext, {\n\n        /**\n         * @property {String} [name='Ext']\n         * <p>The name of the property in the global namespace (The <code>window</code> in browser environments) which refers to the current instance of Ext.</p>\n         * <p>This is usually <code>\"Ext\"</code>, but if a sandboxed build of ExtJS is being used, this will be an alternative name.</p>\n         * <p>If code is being generated for use by <code>eval</code> or to create a <code>new Function</code>, and the global instance\n         * of Ext must be referenced, this is the name that should be built into the code.</p>\n         */\n        name: Ext.sandboxName || 'Ext',\n\n        /**\n         * @property {Function}\n         * A reusable empty function\n         */\n        emptyFn: emptyFn,\n        \n        /**\n         * A reusable identity function. The function will always return the first argument, unchanged.\n         */\n        identityFn: function(o) {\n            return o;\n        },\n\n        /**\n         * A zero length string which will pass a truth test. Useful for passing to methods\n         * which use a truth test to reject <i>falsy</i> values where a string value must be cleared.\n         */\n        emptyString: new String(),\n\n        baseCSSPrefix: Ext.buildSettings.baseCSSPrefix,\n\n        /**\n         * Copies all the properties of config to object if they don't already exist.\n         * @param {Object} object The receiver of the properties\n         * @param {Object} config The source of the properties\n         * @return {Object} returns obj\n         */\n        applyIf: function(object, config) {\n            var property;\n\n            if (object) {\n                for (property in config) {\n                    if (object[property] === undefined) {\n                        object[property] = config[property];\n                    }\n                }\n            }\n\n            return object;\n        },\n\n        /**\n         * Iterates either an array or an object. This method delegates to\n         * {@link Ext.Array#each Ext.Array.each} if the given value is iterable, and {@link Ext.Object#each Ext.Object.each} otherwise.\n         *\n         * @param {Object/Array} object The object or array to be iterated.\n         * @param {Function} fn The function to be called for each iteration. See and {@link Ext.Array#each Ext.Array.each} and\n         * {@link Ext.Object#each Ext.Object.each} for detailed lists of arguments passed to this function depending on the given object\n         * type that is being iterated.\n         * @param {Object} scope (Optional) The scope (`this` reference) in which the specified function is executed.\n         * Defaults to the object being iterated itself.\n         * @markdown\n         */\n        iterate: function(object, fn, scope) {\n            if (Ext.isEmpty(object)) {\n                return;\n            }\n\n            if (scope === undefined) {\n                scope = object;\n            }\n\n            if (Ext.isIterable(object)) {\n                Ext.Array.each.call(Ext.Array, object, fn, scope);\n            }\n            else {\n                Ext.Object.each.call(Ext.Object, object, fn, scope);\n            }\n        }\n    });\n\n    Ext.apply(Ext, {\n\n        /**\n         * This method deprecated. Use {@link Ext#define Ext.define} instead.\n         * @method\n         * @param {Function} superclass\n         * @param {Object} overrides\n         * @return {Function} The subclass constructor from the <tt>overrides</tt> parameter, or a generated one if not provided.\n         * @deprecated 4.0.0 Use {@link Ext#define Ext.define} instead\n         */\n        extend: (function() {\n            // inline overrides\n            var objectConstructor = objectPrototype.constructor,\n                inlineOverrides = function(o) {\n                for (var m in o) {\n                    if (!o.hasOwnProperty(m)) {\n                        continue;\n                    }\n                    this[m] = o[m];\n                }\n            };\n\n            return function(subclass, superclass, overrides) {\n                // First we check if the user passed in just the superClass with overrides\n                if (Ext.isObject(superclass)) {\n                    overrides = superclass;\n                    superclass = subclass;\n                    subclass = overrides.constructor !== objectConstructor ? overrides.constructor : function() {\n                        superclass.apply(this, arguments);\n                    };\n                }\n\n                //<debug>\n                if (!superclass) {\n                    Ext.Error.raise({\n                        sourceClass: 'Ext',\n                        sourceMethod: 'extend',\n                        msg: 'Attempting to extend from a class which has not been loaded on the page.'\n                    });\n                }\n                //</debug>\n\n                // We create a new temporary class\n                var F = function() {},\n                    subclassProto, superclassProto = superclass.prototype;\n\n                F.prototype = superclassProto;\n                subclassProto = subclass.prototype = new F();\n                subclassProto.constructor = subclass;\n                subclass.superclass = superclassProto;\n\n                if (superclassProto.constructor === objectConstructor) {\n                    superclassProto.constructor = superclass;\n                }\n\n                subclass.override = function(overrides) {\n                    Ext.override(subclass, overrides);\n                };\n\n                subclassProto.override = inlineOverrides;\n                subclassProto.proto = subclassProto;\n\n                subclass.override(overrides);\n                subclass.extend = function(o) {\n                    return Ext.extend(subclass, o);\n                };\n\n                return subclass;\n            };\n        }()),\n\n        /**\n         * Overrides members of the specified `target` with the given values.\n         * \n         * If the `target` is a class declared using {@link Ext#define Ext.define}, the\n         * `override` method of that class is called (see {@link Ext.Base#override}) given\n         * the `overrides`.\n         *\n         * If the `target` is a function, it is assumed to be a constructor and the contents\n         * of `overrides` are applied to its `prototype` using {@link Ext#apply Ext.apply}.\n         * \n         * If the `target` is an instance of a class declared using {@link Ext#define Ext.define},\n         * the `overrides` are applied to only that instance. In this case, methods are\n         * specially processed to allow them to use {@link Ext.Base#callParent}.\n         * \n         *      var panel = new Ext.Panel({ ... });\n         *      \n         *      Ext.override(panel, {\n         *          initComponent: function () {\n         *              // extra processing...\n         *              \n         *              this.callParent();\n         *          }\n         *      });\n         *\n         * If the `target` is none of these, the `overrides` are applied to the `target`\n         * using {@link Ext#apply Ext.apply}.\n         *\n         * Please refer to {@link Ext#define Ext.define} and {@link Ext.Base#override} for\n         * further details.\n         *\n         * @param {Object} target The target to override.\n         * @param {Object} overrides The properties to add or replace on `target`. \n         * @method override\n         */\n        override: function (target, overrides) {\n            if (target.$isClass) {\n                target.override(overrides);\n            } else if (typeof target == 'function') {\n                Ext.apply(target.prototype, overrides);\n            } else {\n                var owner = target.self,\n                    name, value;\n\n                if (owner && owner.$isClass) { // if (instance of Ext.define'd class)\n                    for (name in overrides) {\n                        if (overrides.hasOwnProperty(name)) {\n                            value = overrides[name];\n\n                            if (typeof value == 'function') {\n                                //<debug>\n                                if (owner.$className) {\n                                    value.displayName = owner.$className + '#' + name;\n                                }\n                                //</debug>\n\n                                value.$name = name;\n                                value.$owner = owner;\n                                value.$previous = target.hasOwnProperty(name)\n                                    ? target[name] // already hooked, so call previous hook\n                                    : callOverrideParent; // calls by name on prototype\n                            }\n\n                            target[name] = value;\n                        }\n                    }\n                } else {\n                    Ext.apply(target, overrides);\n                }\n            }\n\n            return target;\n        }\n    });\n\n    // A full set of static methods to do type checking\n    Ext.apply(Ext, {\n\n        /**\n         * Returns the given value itself if it's not empty, as described in {@link Ext#isEmpty}; returns the default\n         * value (second argument) otherwise.\n         *\n         * @param {Object} value The value to test\n         * @param {Object} defaultValue The value to return if the original value is empty\n         * @param {Boolean} allowBlank (optional) true to allow zero length strings to qualify as non-empty (defaults to false)\n         * @return {Object} value, if non-empty, else defaultValue\n         */\n        valueFrom: function(value, defaultValue, allowBlank){\n            return Ext.isEmpty(value, allowBlank) ? defaultValue : value;\n        },\n\n        /**\n         * Returns the type of the given variable in string format. List of possible values are:\n         *\n         * - `undefined`: If the given value is `undefined`\n         * - `null`: If the given value is `null`\n         * - `string`: If the given value is a string\n         * - `number`: If the given value is a number\n         * - `boolean`: If the given value is a boolean value\n         * - `date`: If the given value is a `Date` object\n         * - `function`: If the given value is a function reference\n         * - `object`: If the given value is an object\n         * - `array`: If the given value is an array\n         * - `regexp`: If the given value is a regular expression\n         * - `element`: If the given value is a DOM Element\n         * - `textnode`: If the given value is a DOM text node and contains something other than whitespace\n         * - `whitespace`: If the given value is a DOM text node and contains only whitespace\n         *\n         * @param {Object} value\n         * @return {String}\n         * @markdown\n         */\n        typeOf: function(value) {\n            var type,\n                typeToString;\n            \n            if (value === null) {\n                return 'null';\n            }\n\n            type = typeof value;\n\n            if (type === 'undefined' || type === 'string' || type === 'number' || type === 'boolean') {\n                return type;\n            }\n\n            typeToString = toString.call(value);\n\n            switch(typeToString) {\n                case '[object Array]':\n                    return 'array';\n                case '[object Date]':\n                    return 'date';\n                case '[object Boolean]':\n                    return 'boolean';\n                case '[object Number]':\n                    return 'number';\n                case '[object RegExp]':\n                    return 'regexp';\n            }\n\n            if (type === 'function') {\n                return 'function';\n            }\n\n            if (type === 'object') {\n                if (value.nodeType !== undefined) {\n                    if (value.nodeType === 3) {\n                        return (nonWhitespaceRe).test(value.nodeValue) ? 'textnode' : 'whitespace';\n                    }\n                    else {\n                        return 'element';\n                    }\n                }\n\n                return 'object';\n            }\n\n            //<debug error>\n            Ext.Error.raise({\n                sourceClass: 'Ext',\n                sourceMethod: 'typeOf',\n                msg: 'Failed to determine the type of the specified value \"' + value + '\". This is most likely a bug.'\n            });\n            //</debug>\n        },\n\n        /**\n         * Coerces the first value if possible so that it is comparable to the second value.\n         *\n         * Coercion only works between the basic atomic data types String, Boolean, Number, Date, null and undefined.\n         *\n         * Numbers and numeric strings are coerced to Dates using the value as the millisecond era value.\n         *\n         * Strings are coerced to Dates by parsing using the {@link Ext.Date#defaultFormat defaultFormat}.\n         * \n         * For example\n         *\n         *     Ext.coerce('false', true);\n         *     \n         * returns the boolean value `false` because the second parameter is of type `Boolean`.\n         * \n         * @param {Mixed} from The value to coerce\n         * @param {Mixed} to The value it must be compared against\n         * @return The coerced value.\n         */\n        coerce: function(from, to) {\n            var fromType = Ext.typeOf(from),\n                toType = Ext.typeOf(to),\n                isString = typeof from === 'string';\n\n            if (fromType !== toType) {\n                switch (toType) {\n                    case 'string':\n                        return String(from);\n                    case 'number':\n                        return Number(from);\n                    case 'boolean':\n                        return isString && (!from || from === 'false') ? false : Boolean(from);\n                    case 'null':\n                        return isString && (!from || from === 'null') ? null : from;\n                    case 'undefined':\n                        return isString && (!from || from === 'undefined') ? undefined : from;\n                    case 'date':\n                        return isString && isNaN(from) ? Ext.Date.parse(from, Ext.Date.defaultFormat) : Date(Number(from));\n                }\n            }\n            return from;\n        },\n\n        /**\n         * Returns true if the passed value is empty, false otherwise. The value is deemed to be empty if it is either:\n         *\n         * - `null`\n         * - `undefined`\n         * - a zero-length array\n         * - a zero-length string (Unless the `allowEmptyString` parameter is set to `true`)\n         *\n         * @param {Object} value The value to test\n         * @param {Boolean} allowEmptyString (optional) true to allow empty strings (defaults to false)\n         * @return {Boolean}\n         * @markdown\n         */\n        isEmpty: function(value, allowEmptyString) {\n            return (value === null) || (value === undefined) || (!allowEmptyString ? value === '' : false) || (Ext.isArray(value) && value.length === 0);\n        },\n\n        /**\n         * Returns true if the passed value is a JavaScript Array, false otherwise.\n         *\n         * @param {Object} target The target to test\n         * @return {Boolean}\n         * @method\n         */\n        isArray: ('isArray' in Array) ? Array.isArray : function(value) {\n            return toString.call(value) === '[object Array]';\n        },\n\n        /**\n         * Returns true if the passed value is a JavaScript Date object, false otherwise.\n         * @param {Object} object The object to test\n         * @return {Boolean}\n         */\n        isDate: function(value) {\n            return toString.call(value) === '[object Date]';\n        },\n\n        /**\n         * Returns true if the passed value is a JavaScript Object, false otherwise.\n         * @param {Object} value The value to test\n         * @return {Boolean}\n         * @method\n         */\n        isObject: (toString.call(null) === '[object Object]') ?\n        function(value) {\n            // check ownerDocument here as well to exclude DOM nodes\n            return value !== null && value !== undefined && toString.call(value) === '[object Object]' && value.ownerDocument === undefined;\n        } :\n        function(value) {\n            return toString.call(value) === '[object Object]';\n        },\n\n        /**\n         * @private\n         */\n        isSimpleObject: function(value) {\n            return value instanceof Object && value.constructor === Object;\n        },\n        /**\n         * Returns true if the passed value is a JavaScript 'primitive', a string, number or boolean.\n         * @param {Object} value The value to test\n         * @return {Boolean}\n         */\n        isPrimitive: function(value) {\n            var type = typeof value;\n\n            return type === 'string' || type === 'number' || type === 'boolean';\n        },\n\n        /**\n         * Returns true if the passed value is a JavaScript Function, false otherwise.\n         * @param {Object} value The value to test\n         * @return {Boolean}\n         * @method\n         */\n        isFunction: function(value) {\n            return !!(value && value.$extIsFunction);\n        },\n\n        /**\n         * Returns true if the passed value is a number. Returns false for non-finite numbers.\n         * @param {Object} value The value to test\n         * @return {Boolean}\n         */\n        isNumber: function(value) {\n            return typeof value === 'number' && isFinite(value);\n        },\n\n        /**\n         * Validates that a value is numeric.\n         * @param {Object} value Examples: 1, '1', '2.34'\n         * @return {Boolean} True if numeric, false otherwise\n         */\n        isNumeric: function(value) {\n            return !isNaN(parseFloat(value)) && isFinite(value);\n        },\n\n        /**\n         * Returns true if the passed value is a string.\n         * @param {Object} value The value to test\n         * @return {Boolean}\n         */\n        isString: function(value) {\n            return typeof value === 'string';\n        },\n\n        /**\n         * Returns true if the passed value is a boolean.\n         *\n         * @param {Object} value The value to test\n         * @return {Boolean}\n         */\n        isBoolean: function(value) {\n            return typeof value === 'boolean';\n        },\n\n        /**\n         * Returns true if the passed value is an HTMLElement\n         * @param {Object} value The value to test\n         * @return {Boolean}\n         */\n        isElement: function(value) {\n            return value ? value.nodeType === 1 : false;\n        },\n\n        /**\n         * Returns true if the passed value is a TextNode\n         * @param {Object} value The value to test\n         * @return {Boolean}\n         */\n        isTextNode: function(value) {\n            return value ? value.nodeName === \"#text\" : false;\n        },\n\n        /**\n         * Returns true if the passed value is defined.\n         * @param {Object} value The value to test\n         * @return {Boolean}\n         */\n        isDefined: function(value) {\n            return typeof value !== 'undefined';\n        },\n\n        /**\n         * Returns `true` if the passed value is iterable, that is, if elements of it are addressable using array\n         * notation with numeric indices, `false` otherwise.\n         *\n         * Arrays and function `arguments` objects are iterable. Also HTML collections such as `NodeList` and `HTMLCollection'\n         * are iterable.\n         *\n         * @param {Object} value The value to test\n         * @return {Boolean}\n         */\n        isIterable: function(value) {\n            // To be iterable, the object must have a numeric length property and must not be a string or function.\n            if (!value || typeof value.length !== 'number' || typeof value === 'string' || value.$extIsFunction) {\n                return false;\n            }\n\n            // Certain \"standard\" collections in IE (such as document.images) do not offer the correct\n            // Javascript Object interface; specifically, they lack the propertyIsEnumerable method.\n            // And the item property while it does exist is not typeof \"function\"\n            if (!value.propertyIsEnumerable) {\n                return !!value.item;\n            }\n\n            // If it is a regular, interrogatable JS object (not an IE ActiveX object), then...\n            // If it has its own property called \"length\", but not enumerable, it's iterable\n            if (value.hasOwnProperty('length') && !value.propertyIsEnumerable('length')) {\n                return true;\n            }\n\n            // Test against whitelist which includes known iterable collection types\n            return iterableRe.test(toString.call(value));\n        }\n    });\n\n    Ext.apply(Ext, {\n\n        /**\n         * Clone simple variables including array, {}-like objects, DOM nodes and Date without keeping the old reference.\n         * A reference for the object itself is returned if it's not a direct decendant of Object. For model cloning,\n         * see {@link Ext.data.Model#copy Model.copy}.\n         * \n         * @param {Object} item The variable to clone\n         * @return {Object} clone\n         */\n        clone: function(item) {\n            var type,\n                i,\n                j,\n                k,\n                clone,\n                key;\n            \n            if (item === null || item === undefined) {\n                return item;\n            }\n\n            // DOM nodes\n            // TODO proxy this to Ext.Element.clone to handle automatic id attribute changing\n            // recursively\n            if (item.nodeType && item.cloneNode) {\n                return item.cloneNode(true);\n            }\n\n            type = toString.call(item);\n\n            // Date\n            if (type === '[object Date]') {\n                return new Date(item.getTime());\n            }\n\n\n            // Array\n            if (type === '[object Array]') {\n                i = item.length;\n\n                clone = [];\n\n                while (i--) {\n                    clone[i] = Ext.clone(item[i]);\n                }\n            }\n            // Object\n            else if (type === '[object Object]' && item.constructor === Object) {\n                clone = {};\n\n                for (key in item) {\n                    clone[key] = Ext.clone(item[key]);\n                }\n\n                if (enumerables) {\n                    for (j = enumerables.length; j--;) {\n                        k = enumerables[j];\n                        if (item.hasOwnProperty(k)) {\n                            clone[k] = item[k];\n                        }\n                    }\n                }\n            }\n\n            return clone || item;\n        },\n\n        /**\n         * @private\n         * Generate a unique reference of Ext in the global scope, useful for sandboxing\n         */\n        getUniqueGlobalNamespace: function() {\n            var uniqueGlobalNamespace = this.uniqueGlobalNamespace,\n                i;\n\n            if (uniqueGlobalNamespace === undefined) {\n                i = 0;\n\n                do {\n                    uniqueGlobalNamespace = 'ExtBox' + (++i);\n                } while (Ext.global[uniqueGlobalNamespace] !== undefined);\n\n                Ext.global[uniqueGlobalNamespace] = Ext;\n                this.uniqueGlobalNamespace = uniqueGlobalNamespace;\n            }\n\n            return uniqueGlobalNamespace;\n        },\n        \n        /**\n         * @private\n         */\n        functionFactoryCache: {},\n        \n        cacheableFunctionFactory: function() {\n            var me = this,\n                args = Array.prototype.slice.call(arguments),\n                cache = me.functionFactoryCache,\n                idx, fn, ln;\n                \n             if (Ext.isSandboxed) {\n                ln = args.length;\n                if (ln > 0) {\n                    ln--;\n                    args[ln] = 'var Ext=window.' + Ext.name + ';' + args[ln];\n                }\n            }\n            idx = args.join('');\n            fn = cache[idx];\n            if (!fn) {\n                fn = Function.prototype.constructor.apply(Function.prototype, args);\n                \n                cache[idx] = fn;\n            }\n            return fn;\n        },\n        \n        functionFactory: function() {\n            var me = this,\n                args = Array.prototype.slice.call(arguments),\n                ln;\n                \n            if (Ext.isSandboxed) {\n                ln = args.length;\n                if (ln > 0) {\n                    ln--;\n                    args[ln] = 'var Ext=window.' + Ext.name + ';' + args[ln];\n                }\n            }\n     \n            return Function.prototype.constructor.apply(Function.prototype, args);\n        },\n\n        /**\n         * @private\n         * @property\n         */\n        Logger: {\n            verbose: emptyFn,\n            log: emptyFn,\n            info: emptyFn,\n            warn: emptyFn,\n            error: function(message) {\n                throw new Error(message);\n            },\n            deprecate: emptyFn\n        }\n    });\n\n    /**\n     * Old alias to {@link Ext#typeOf}\n     * @deprecated 4.0.0 Use {@link Ext#typeOf} instead\n     * @method\n     * @inheritdoc Ext#typeOf\n     */\n    Ext.type = Ext.typeOf;\n    \n    // When using Cmd optimizations, the namespace Ext.app may already be defined\n    // by this point since it's done up front by the tool. Check if app already\n    // exists before overwriting it.\n    ExtApp = Ext.app;\n    if (!ExtApp) {\n        ExtApp = Ext.app = {};\n    }\n    Ext.apply(ExtApp, {\n        namespaces: {},\n        \n        /**\n        * @private\n        */\n        collectNamespaces: function(paths) {\n            var namespaces = Ext.app.namespaces,\n                path;\n            \n            for (path in paths) {\n                if (paths.hasOwnProperty(path)) {\n                    namespaces[path] = true;\n                }\n            }\n        },\n\n        /**\n        * Adds namespace(s) to known list.\n        *\n        * @param {String/String[]} namespace\n        */\n        addNamespaces: function(ns) {\n            var namespaces = Ext.app.namespaces,\n                i, l;\n\n            if (!Ext.isArray(ns)) {\n                ns = [ns];\n            }\n\n            for (i = 0, l = ns.length; i < l; i++) {\n                namespaces[ns[i]] = true;\n            }\n        },\n\n        /**\n        * @private Clear all namespaces from known list.\n        */\n        clearNamespaces: function() {\n            Ext.app.namespaces = {};\n        },\n\n        /**\n        * Get namespace prefix for a class name.\n        *\n        * @param {String} className\n        *\n        * @return {String} Namespace prefix if it's known, otherwise undefined\n        */\n        getNamespace: function(className) {\n            var namespaces    = Ext.app.namespaces,\n                deepestPrefix = '',\n                prefix;\n\n            for (prefix in namespaces) {\n                if (namespaces.hasOwnProperty(prefix)    &&\n                    prefix.length > deepestPrefix.length &&\n                    (prefix + '.' === className.substring(0, prefix.length + 1))) {\n                    deepestPrefix = prefix;\n                }\n            }\n\n            return deepestPrefix === '' ? undefined : deepestPrefix;\n        }\n    });\n}());\n\n/*\n * This method evaluates the given code free of any local variable. In some browsers this\n * will be at global scope, in others it will be in a function.\n * @parma {String} code The code to evaluate.\n * @private\n * @method\n */\nExt.globalEval = Ext.global.execScript\n    ? function(code) {\n        execScript(code);\n    }\n    : function($$code) {\n        // IMPORTANT: because we use eval we cannot place this in the above function or it\n        // will break the compressor's ability to rename local variables...\n        (function(){\n            // This var should not be replaced by the compressor. We need to do this so\n            // that Ext refers to the global Ext, if we're sandboxing it may\n            // refer to the local instance inside the closure\n            var Ext = this.Ext;\n            eval($$code);\n        }());\n    };\n"]],"start1":0,"start2":0,"length1":0,"length2":31538}]],"length":31538}
