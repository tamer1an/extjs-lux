<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Date'>/**
</span> * @class Date
 *
 * Creates `Date` instances which let you work with dates and times.
 *
 * If you supply no arguments, the constructor creates a `Date` object for today's
 * date and time according to local time. If you supply some arguments but not
 * others, the missing arguments are set to 0. If you supply any arguments, you
 * must supply at least the year, month, and day. You can omit the hours, minutes,
 * seconds, and milliseconds.
 *
 * The date is measured in milliseconds since midnight 01 January, 1970 UTC. A day
 * holds 86,400,000 milliseconds. The `Date` object range is -100,000,000 days to
 * 100,000,000 days relative to 01 January, 1970 UTC.
 *
 * The `Date` object provides uniform behavior across platforms.
 *
 * The `Date` object supports a number of UTC (universal) methods, as well as
 * local time methods. UTC, also known as Greenwich Mean Time (GMT), refers to the
 * time as set by the World Time Standard. The local time is the time known to the
 * computer where JavaScript is executed.
 *
 * Invoking `Date` in a non-constructor context (i.e., without the `new` operator)
 * will return a string representing the current time.
 *
 * Note that `Date` objects can only be instantiated by calling `Date` or using it
 * as a constructor; unlike other JavaScript object types, `Date` objects have no
 * literal syntax.
 *
 * # Several ways to assign dates
 *
 * The following example shows several ways to assign dates:
 *
 *     today = new Date();
 *     birthday = new Date(&quot;December 19, 1989 03:24:00&quot;);
 *     birthday = new Date(1989,11,19);
 *     birthday = new Date(1989,11,17,3,24,0);
 *
 * # Calculating elapsed time
 *
 * The following examples show how to determine the elapsed time between two dates:
 *
 *     // using static methods
 *     var start = Date.now();
 *     // the event you'd like to time goes here:
 *     doSomethingForALongTime();
 *     var end = Date.now();
 *     var elapsed = end - start; // time in milliseconds
 *
 *     // if you have Date objects
 *     var start = new Date();
 *     // the event you'd like to time goes here:
 *     doSomethingForALongTime();
 *     var end = new Date();
 *     var elapsed = end.getTime() - start.getTime(); // time in milliseconds
 *
 *     // if you want to test a function and get back its return
 *     function printElapsedTime (fTest) {
 *         var nStartTime = Date.now(), vReturn = fTest(), nEndTime = Date.now();
 *         alert(&quot;Elapsed time: &quot; + String(nEndTime - nStartTime) + &quot;
 *         milliseconds&quot;);
 *         return vReturn;
 *     }
 *
 *     yourFunctionReturn = printElapsedTime(yourFunction);
 *
 * # ISO 8601 formatted dates
 *
 * The following example shows how to formate a date in an ISO 8601 format using
 * UTC:
 *
 *     // use a function for the exact format desired...
 *     function ISODateString(d){
 *     function pad(n){return n&lt;10 ? '0'+n : n}
 *     return d.getUTCFullYear()+'-'
 *         + pad(d.getUTCMonth()+1)+'-'
 *         + pad(d.getUTCDate())+'T'
 *         + pad(d.getUTCHours())+':'
 *         + pad(d.getUTCMinutes())+':'
 *         + pad(d.getUTCSeconds())+'Z'}
 *
 *     var d = new Date();
 *     print(ISODateString(d)); // prints something like 2009-09-28T19:03:12Z
 *
 * &lt;div class=&quot;notice&quot;&gt;
 * Documentation for this class comes from &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date&quot;&gt;MDN&lt;/a&gt;
 * and is available under &lt;a href=&quot;http://creativecommons.org/licenses/by-sa/2.0/&quot;&gt;Creative Commons: Attribution-Sharealike license&lt;/a&gt;.
 * &lt;/div&gt;
 */

<span id='Date-method-constructor'>/**
</span> * @method constructor
 * Creates new Date object.
 *
 * @param {Number/String} [year]
 * Either UNIX timestamp, date string, or year (when month and day parameters also provided):
 *
 * - Integer value representing the number of milliseconds since 1 January 1970
 *   00:00:00 UTC (Unix Epoch).
 *
 * - String value representing a date. The string should be in a format recognized
 *   by the parse method (IETF-compliant RFC 1123 timestamps).
 *
 * - Integer value representing the year. For compatibility (in order to avoid the
 *   Y2K problem), you should always specify the year in full; use 1998, rather
 *   than 98.
 *
 * @param {Number} [month]
 * Integer value representing the month, beginning with 0 for January to 11
 * for December.
 * @param {Number} [day]
 * Integer value representing the day of the month (1-31).
 * @param {Number} [hour]
 * Integer value representing the hour of the day (0-23).
 * @param {Number} [minute]
 * Integer value representing the minute segment (0-59) of a time reading.
 * @param {Number} [second]
 * Integer value representing the second segment (0-59) of a time reading.
 * @param {Number} [millisecond]
 * Integer value representing the millisecond segment (0-999) of a time reading.
 */


//Methods

<span id='Date-static-method-now'>/**
</span> * @method now
 * @static
 * Returns the numeric value corresponding to the current time.
 *
 * The `now` method returns the milliseconds elapsed since 1 January 1970 00:00:00 UTC up until now as
 * a number.
 *
 * When using `now` to create timestamps or unique IDs, keep in mind that the resolution may be 15
 * milliseconds on Windows, so you could end up with several equal values if `now` is called multiple
 * times within a short time span.
 *
 * @return {Number} Returns the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC.
 */

<span id='Date-static-method-parse'>/**
</span> * @method parse
 * @static
 * Parses a string representation of a date, and returns the number of milliseconds
 * since January 1, 1970, 00:00:00, local time.
 *
 * The `parse` method takes a date string (such as `&quot;Dec 25, 1995&quot;`) and returns the number of
 * milliseconds since January 1, 1970, 00:00:00 UTC. The local time zone is used to interpret
 * arguments that do not contain time zone information. This function is useful for setting date
 * values based on string values, for example in conjunction with the `setTime` method and the
 * {@link Date} object.
 *
 * Given a string representing a time, parse returns the time value. It accepts the IETF standard (RFC
 * 1123 Section 5.2.14 and elsewhere) date syntax: `&quot;Mon, 25 Dec 1995 13:30:00 GMT&quot;`. It understands
 * the continental US time-zone abbreviations, but for general use, use a time-zone offset, for
 * example, `&quot;Mon, 25 Dec 1995 13:30:00 GMT+0430&quot;` (4 hours, 30 minutes east of the Greenwich
 * meridian). If you do not specify a time zone, the local time zone is assumed. GMT and UTC are
 * considered equivalent.
 *
 * ### Using parse
 *
 * If `IPOdate` is an existing `Date` object, then you can set it to August 9, 1995 (local time) as
 * follows:
 *
 *     IPOdate.setTime(Date.parse(&quot;Aug 9, 1995&quot;));
 *
 * Some other examples:
 *
 *     // Returns 807937200000 in time zone GMT-0300, and other values in other
 *     // timezones, since the argument does not specify a time zone.
 *     Date.parse(&quot;Aug 9, 1995&quot;);
 *
 *     // Returns 807926400000 no matter the local time zone.
 *     Date.parse(&quot;Wed, 09 Aug 1995 00:00:00 GMT&quot;);
 *
 *     // Returns 807937200000 in timezone GMT-0300, and other values in other
 *     // timezones, since there is no time zone specifier in the argument.
 *     Date.parse(&quot;Wed, 09 Aug 1995 00:00:00&quot;);
 *
 *     // Returns 0 no matter the local time zone.
 *     Date.parse(&quot;Thu, 01 Jan 1970 00:00:00 GMT&quot;);
 *
 *     // Returns 14400000 in timezone GMT-0400, and other values in other
 *     // timezones, since there is no time zone specifier in the argument.
 *     Date.parse(&quot;Thu, 01 Jan 1970 00:00:00&quot;);
 *
 *     // Returns 14400000 no matter the local time zone.
 *     Date.parse(&quot;Thu, 01 Jan 1970 00:00:00 GMT-0400&quot;);
 *
 * @param {String} dateString A string representing a date.
 * @return {Number} Number of milliseconds since January 1, 1970, 00:00:00, local time.
 */

<span id='Date-static-method-UTC'>/**
</span> * @method UTC
 * @static
 * Accepts the same parameters as the longest form of the constructor, and returns
 * the number of milliseconds in a `Date` object since January 1, 1970, 00:00:00,
 * universal time.
 *
 * `UTC` takes comma-delimited date parameters and returns the number of milliseconds between January
 * 1, 1970, 00:00:00, universal time and the time you specified.
 *
 * You should specify a full year for the year; for example, 1998. If a year between 0 and 99 is
 * specified, the method converts the year to a year in the 20th century (1900 + year); for example,
 * if you specify 95, the year 1995 is used.
 *
 * The `UTC` method differs from the `Date` constructor in two ways.
 * *   `Date.UTC` uses universal time instead of the local time.
 * *   `Date.UTC` returns a time value as a number instead of creating a `Date` object.
 *
 * If a parameter you specify is outside of the expected range, the `UTC` method updates the other
 * parameters to allow for your number. For example, if you use 15 for month, the year will be
 * incremented by 1 (year + 1), and 3 will be used for the month.
 *
 * Because `UTC` is a static method of `Date`, you always use it as `Date.UTC()`, rather than as a
 * method of a `Date` object you created.
*
 * The following statement creates a `Date` object using GMT instead of local time:
 *
 *     gmtDate = new Date(Date.UTC(96, 11, 1, 0, 0, 0));
 *
 * @param {Number} year A year after 1900.
 * @param {Number} month An integer between 0 and 11 representing the month.
 * @param {Number} date An integer between 1 and 31 representing the day of the month.
 * @param {Number} hrs An integer between 0 and 23 representing the hours.
 * @param {Number} min An integer between 0 and 59 representing the minutes.
 * @param {Number} sec An integer between 0 and 59 representing the seconds.
 * @param {Number} ms An integer between 0 and 999 representing the milliseconds.
 * @return {Date} Number of milliseconds since January 1, 1970, 00:00:00, universal time.
 */

//Methods

<span id='Date-method-getDate'>/**
</span> * @method getDate
 * Returns the numeric value corresponding to the current time.
 *
 * The second statement below assigns the value 25 to the variable `day`, based on the value of the
 * `Date` object `Xmas95`.
 *
 *     Xmas95 = new Date(&quot;December 25, 1995 23:15:00&quot;)
 *     day = Xmas95.getDate()
 *
 * @return {Number} Value between 1 and 31.
 */

<span id='Date-method-getDay'>/**
</span> * @method getDay
 * Returns the numeric value corresponding to the current time.
 *
 * The value returned by `getDay` is an integer corresponding to the day of the week: 0 for Sunday, 1
 * for Monday, 2 for Tuesday, and so on.
 *
 * The second statement below assigns the value 1 to `weekday`, based on the value of the `Date`
 * object `Xmas95`. December 25, 1995, is a Monday.
 *
 *     Xmas95 = new Date(&quot;December 25, 1995 23:15:00&quot;);
 *     weekday = Xmas95.getDay();
 *
 * @return {Number} A numeric representation of the day from Sunday (0) to
 * Saturday (6).
 */

<span id='Date-method-getFullYear'>/**
</span> * @method getFullYear
 * Returns the numeric value corresponding to the current time.
 *
 * The value returned by `getFullYear` is an absolute number. For dates between the years 1000 and
 * 9999, `getFullYear` returns a four-digit number, for example, 1995. Use this function to make sure
 * a year is compliant with years after 2000.
 *
 * Use this method instead of the `getYear` method.
 *
 * The following example assigns the four-digit value of the current year to the variable yr.
 *
 *     var today = new Date();
 *     var yr = today.getFullYear();
 *
 * @return {Number} Four digit representation of the year.
 */

<span id='Date-method-getHours'>/**
</span> * @method getHours
 * Returns the numeric value corresponding to the current time.
 *
 * The second statement below assigns the value 23 to the variable `hours`, based on the value of the
 * `Date` object `Xmas95`.
 *
 *     Xmas95 = new Date(&quot;December 25, 1995 23:15:00&quot;)
 *     hours = Xmas95.getHours()
 *
 * @return {Number} Value between 0 and 23, using 24-hour clock.
 */

<span id='Date-method-getMilliseconds'>/**
</span> * @method getMilliseconds
 * Returns the numeric value corresponding to the current time.
 *
 * The following example assigns the milliseconds portion of the current time to the variable ms.
 *
 *     var ms;
 *     Today = new Date();
 *     ms = Today.getMilliseconds();
 *
 * @return {Number} A number between 0 and 999.
 */

<span id='Date-method-getMinutes'>/**
</span> * @method getMinutes
 * Returns the numeric value corresponding to the current time.
 *
 * The second statement below assigns the value 15 to the variable `minutes`, based on the value of
 * the `Date` object `Xmas95`.
 *
 *     Xmas95 = new Date(&quot;December 25, 1995 23:15:00&quot;)
 *     minutes = Xmas95.getMinutes()
 *
 * @return {Number} Value between 0 and 59.
 */

<span id='Date-method-getMonth'>/**
</span> * @method getMonth
 * Returns the numeric value corresponding to the current time.
 *
 * The second statement below assigns the value 11 to the variable `month`, based on the value of the
 * `Date` object `Xmas95`.
 *
 *     Xmas95 = new Date(&quot;December 25, 1995 23:15:00&quot;)
 *     month = Xmas95.getMonth()
 *
 * @return {Number} An integer between 0 and 11. 0 corresponds to January, 1 to February, and so on.
 */

<span id='Date-method-getSeconds'>/**
</span> * @method getSeconds
 * Returns the numeric value corresponding to the current time.
 *
 * The second statement below assigns the value 30 to the variable `secs`, based on the value of the
 * `Date` object `Xmas95`.
 *
 *     Xmas95 = new Date(&quot;December 25, 1995 23:15:30&quot;)
 *     secs = Xmas95.getSeconds()
 *
 * @return {Number} Value between 0 and 59.
 */

<span id='Date-method-getTime'>/**
</span> * @method getTime
 * Returns the numeric value corresponding to the current time.
 *
 * The value returned by the `getTime` method is the number of milliseconds since 1 January 1970
 * 00:00:00 UTC. You can use this method to help assign a date and time to another `Date` object.
 *
 * This method is functionally equivalent to the `valueOf` method.
 *
 * Using getTime for copying dates
 *
 * Constructing a date object with the identical time value.
 *
 *     var birthday = new Date(1994, 12, 10);
 *     var copy = new Date();
 *     copy.setTime(birthday.getTime());
 *
 * Measuring execution time
 *
 * Subtracting two subsequent getTime calls on newly generated Date objects, give the time span
 * between these two calls. This can be used to calculate the executing time of some operations.
 *
 *     var end, start;
 *
 *     start = new Date();
 *     for (var i = 0; i &lt; 1000; i++)
 *         Math.sqrt(i);
 *     end = new Date();
 *
 *     console.log(&quot;Operation took &quot; + (end.getTime() - start.getTime()) + &quot; msec&quot;);
 *
 * @return {Number} Number of milliseconds since 1/1/1970 (GMT).
 */

<span id='Date-method-getTimezoneOffset'>/**
</span> * @method getTimezoneOffset
 * Returns the numeric value corresponding to the current time.
 *
 * The time-zone offset is the difference, in minutes, between UTC and local time. Note that this
 * means that the offset is positive if the local timezone is behind UTC and negative if it is ahead.
 * For example, if your time zone is UTC+10 (Australian Eastern Standard Time), -600 will be returned.
 * Daylight savings time prevents this value from being a constant even for a given loca